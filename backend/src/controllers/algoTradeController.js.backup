import { Trade, Strategy, ApiKey, User, StrategySubscription } from '../models/index.js';
import { mt5Broker } from '../../algoengine/index.js';
import { emitTradeUpdate } from '../config/socket.js';
import { Op } from 'sequelize';
import crypto from 'crypto';

/**
 * Execute Trade Based on Strategy Configuration
 * POST /api/algo-trades/execute
 * 
 * Request Body:
 * {
 *   "strategyId": 123,
 *   "signal": "BUY" | "SELL",
 *   "symbol": "EURUSD" (optional - uses strategy symbol if not provided)
 * }
 */
export const executeStrategyTrade = async (req, res) => {
  try {
    const userId = req.user.id;
    const { strategyId, signal, symbol: customSymbol } = req.body;

    // Validate input
    if (!strategyId) {
      return res.status(400).json({ 
        success: false, 
        error: 'strategyId is required' 
      });
    }

    if (!signal || !['BUY', 'SELL'].includes(signal.toUpperCase())) {
      return res.status(400).json({ 
        success: false, 
        error: 'signal must be either BUY or SELL' 
      });
    }

    // Fetch strategy with user verification
    const strategy = await Strategy.findOne({
      where: { id: strategyId, userId }
    });

    if (!strategy) {
      return res.status(404).json({ 
        success: false, 
        error: 'Strategy not found or access denied' 
      });
    }

    // Check if strategy is active
    if (!strategy.isActive) {
      return res.status(400).json({ 
        success: false, 
        error: 'Strategy is not active' 
      });
    }

    // Get trading symbol
    const symbol = customSymbol || strategy.symbol;
    if (!symbol) {
      return res.status(400).json({ 
        success: false, 
        error: 'Symbol is required. Provide in request or set in strategy.' 
      });
    }

    // Parse market risk configuration
    const marketRisk = strategy.marketRisk || {};
    const {
      stopLossType = 'points',
      stopLossValue = 50,
      takeProfitType = 'points',
      takeProfitValue = 100,
      trailingStopLoss = false,
      trailingStopValue = 0,
      riskPercent = 1,
      usePositionSizing = false
    } = marketRisk;

    // Get user's API key for the strategy segment
    const apiKey = await ApiKey.findOne({
      where: { 
        userId,
        segment: strategy.segment,
        broker: 'MT5' // Currently only MT5 supported
      }
    });

    if (!apiKey) {
      return res.status(404).json({ 
        success: false, 
        error: `No MT5 API key found for ${strategy.segment} segment. Please add your MT5 credentials first.` 
      });
    }

    // Validate MT5 credentials
    if (!apiKey.accessToken || !apiKey.appName) {
      return res.status(400).json({ 
        success: false, 
        error: 'Invalid MT5 credentials',
        details: 'Both Access Token and Account ID are required. Please update your MT5 API key.' 
      });
    }

    // Get lots from strategy (default to 0.01 if not specified)
    const volume = strategy.lots || 0.01;

    // Initialize MT5 broker if not already connected
    try {
      const isConnected = await mt5Broker.healthCheck();
      if (!isConnected) {
        await mt5Broker.initialize({
          apiKey: apiKey.accessToken, // MetaAPI JWT token
          accountId: apiKey.appName   // MT5 account ID
        });
      }
    } catch (initError) {
      console.error('MT5 initialization error:', initError);
      return res.status(500).json({ 
        success: false, 
        error: 'Failed to connect to MT5 broker',
        details: initError.message
      });
    }

    // Get account info for position sizing
    let accountInfo;
    try {
      accountInfo = await mt5Broker.getAccountInfo();
    } catch (accountError) {
      console.error('Get account info error:', accountError);
      return res.status(500).json({ 
        success: false, 
        error: 'Failed to retrieve account information',
        details: accountError.message
      });
    }

    // Calculate position size if enabled
    let calculatedVolume = volume;
    if (usePositionSizing && accountInfo) {
      try {
        const currentPrice = await mt5Broker.getPrice(symbol);
        const slPrice = signal === 'BUY' 
          ? currentPrice.bid - (stopLossValue * 0.0001) // Approximate for points
          : currentPrice.ask + (stopLossValue * 0.0001);
        
        const { CalculationService } = await import('../../algoengine/brokers/mt5/services/CalculationService.js');
        calculatedVolume = CalculationService.calculatePositionSize(
          accountInfo.balance,
          riskPercent,
          currentPrice.bid,
          slPrice
        );
        
        // Round to 2 decimal places and ensure minimum lot size
        calculatedVolume = Math.max(0.01, Math.round(calculatedVolume * 100) / 100);
      } catch (sizeError) {
        console.error('Position sizing error:', sizeError);
        // Continue with default volume if calculation fails
      }
    }

    // Prepare trade parameters
    const tradeParams = {
      symbol: symbol.toUpperCase(),
      type: signal.toUpperCase(),
      volume: calculatedVolume,
      stopLoss: {
        type: stopLossType,
        value: stopLossValue
      },
      takeProfit: {
        type: takeProfitType,
        value: takeProfitValue
      },
      comment: `Strategy: ${strategy.name} (ID: ${strategyId})`
    };

    // Execute trade via MT5 broker
    let tradeResult;
    try {
      console.log(`Executing ${signal} trade for strategy ${strategyId}:`, tradeParams);
      tradeResult = await mt5Broker.placeTrade(tradeParams);
    } catch (tradeError) {
      console.error('Trade execution error:', tradeError);
      
      // Save failed trade to database
      const failedTrade = await Trade.create({
        userId,
        orderId: `FAILED_${Date.now()}`,
        market: strategy.segment,
        symbol: symbol.toUpperCase(),
        type: signal === 'BUY' ? 'Buy' : 'Sell',
        amount: calculatedVolume,
        price: 0,
        status: 'Failed',
        date: new Date(),
        broker: 'MT5',
        brokerType: apiKey.broker,
        strategyId: strategyId,
        // Order-log fields
        signalReceivedAt: new Date(),
        signalPayload: {
          source: 'strategy-execute',
          signal: signal.toUpperCase(),
          symbol: symbol.toUpperCase(),
          strategyId,
          volume: calculatedVolume
        },
        signalSendStatus: 'Failed',
        signalSendError: tradeError?.message,
        filledQuantity: null,
        avgFillPrice: null,
        brokerStatus: 'REJECTED',
        brokerError: tradeError?.message,
        brokerResponse: tradeError?.message,
        brokerResponseJson: {
          error: tradeError?.message,
          name: tradeError?.name,
          stack: tradeError?.stack,
          timestamp: new Date().toISOString()
        }
      });

      console.error(`‚ùå Trade failed for user ${user.email}:`, tradeError.message);
      return res.status(500).json({ 
        success: false, 
        error: 'Trade execution failed',
        message: 'Broker rejected the trade',
        signal: signal.toUpperCase(),
        symbol: symbol.toUpperCase(),
        volume: calculatedVolume,
        strategy: strategy.name,
        broker: 'MT5',
        brokerError: tradeError.message,
        tradeId: failedTrade.id,
        timestamp: new Date().toISOString()
      });
    }

    // Save successful trade to database
    const trade = await Trade.create({
      userId,
      orderId: tradeResult.brokerOrderId || tradeResult.orderId,
      market: strategy.segment,
      symbol: symbol.toUpperCase(),
      type: signal === 'BUY' ? 'Buy' : 'Sell',
      amount: tradeResult.volume,
      price: tradeResult.openPrice,
      currentPrice: tradeResult.openPrice,
      status: tradeResult.status === 'FILLED' ? 'Completed' : 'Pending',
      date: new Date(),
      broker: 'MT5',
      brokerType: apiKey.broker,
      strategyId: strategyId,
      stopLoss: tradeResult.stopLoss,
      takeProfit: tradeResult.takeProfit,
      // Order-log fields
      signalReceivedAt: new Date(),
      signalPayload: {
        source: 'strategy-execute',
        signal: signal.toUpperCase(),
        symbol: symbol.toUpperCase(),
        strategyId,
        volume: calculatedVolume
      },
      signalSendStatus: 'Sent',
      signalSendError: null,
      filledQuantity: tradeResult?.volume ?? calculatedVolume,
      avgFillPrice: tradeResult?.openPrice ?? null,
      brokerStatus: tradeResult?.status || 'UNKNOWN',
      brokerError: null,
      brokerResponse: JSON.stringify({ status: tradeResult?.status || 'UNKNOWN' }),
      brokerResponseJson: {
        ...tradeResult?.brokerResponse,
        executionTime: tradeResult?.executionTime,
        raw: tradeResult,
        timestamp: new Date().toISOString()
      }
    });

    console.log(`‚úÖ Trade executed successfully: ${trade.orderId} - ${signal} ${calculatedVolume} ${symbol} @ ${tradeResult.openPrice}`);

    // Emit real-time update
    emitTradeUpdate(userId, trade, 'create');

    // Prepare response
    res.status(201).json({
      success: true,
      message: 'Trade executed successfully',
      data: {
        tradeId: trade.id,
        orderId: trade.orderId,
        symbol: trade.symbol,
        type: trade.type,
        volume: trade.amount,
        openPrice: trade.price,
        stopLoss: tradeResult.stopLoss,
        takeProfit: tradeResult.takeProfit,
        status: trade.status,
        executionTime: tradeResult.executionTime,
        strategy: {
          id: strategy.id,
          name: strategy.name
        },
        broker: {
          name: 'MT5',
          account: accountInfo.broker
        }
      }
    });

  } catch (error) {
    console.error('Execute strategy trade error:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Internal server error',
      details: error.message 
    });
  }
};

/**
 * Execute Manual Trade with Custom Parameters
 * POST /api/algo-trades/manual
 * 
 * Request Body:
 * {
 *   "symbol": "EURUSD",
 *   "type": "BUY" | "SELL",
 *   "volume": 0.01,
 *   "stopLoss": { "type": "points", "value": 50 },
 *   "takeProfit": { "type": "points", "value": 100 },
 *   "segment": "Forex"
 * }
 */
export const executeManualTrade = async (req, res) => {
  try {
    const userId = req.user.id;
    const { 
      symbol, 
      type, 
      volume, 
      stopLoss, 
      takeProfit, 
      segment = 'Forex',
      comment 
    } = req.body;

    // Validate required fields
    if (!symbol || !type || !volume) {
      return res.status(400).json({ 
        success: false, 
        error: 'symbol, type, and volume are required' 
      });
    }

    if (!['BUY', 'SELL'].includes(type.toUpperCase())) {
      return res.status(400).json({ 
        success: false, 
        error: 'type must be either BUY or SELL' 
      });
    }

    // Get user's API key
    const apiKey = await ApiKey.findOne({
      where: { 
        userId,
        segment,
        broker: 'MT5'
      }
    });

    if (!apiKey) {
      return res.status(404).json({ 
        success: false, 
        error: `No MT5 API key found for ${segment} segment` 
      });
    }

    // Initialize MT5 broker
    try {
      const isConnected = await mt5Broker.healthCheck();
      if (!isConnected) {
        await mt5Broker.initialize({
          apiKey: apiKey.apiKey,
          accountId: apiKey.appName
        });
      }
    } catch (initError) {
      return res.status(500).json({ 
        success: false, 
        error: 'Failed to connect to MT5 broker',
        details: initError.message
      });
    }

    // Prepare trade parameters
    const tradeParams = {
      symbol: symbol.toUpperCase(),
      type: type.toUpperCase(),
      volume: parseFloat(volume),
      stopLoss: stopLoss || { type: 'points', value: 50 },
      takeProfit: takeProfit || { type: 'points', value: 100 },
      comment: comment || `Manual trade by user ${userId}`
    };

    // Execute trade
    const tradeResult = await mt5Broker.placeTrade(tradeParams);

    // Save to database
    const trade = await Trade.create({
      userId,
      orderId: tradeResult.brokerOrderId || tradeResult.orderId,
      market: segment,
      symbol: symbol.toUpperCase(),
      type: type === 'BUY' ? 'Buy' : 'Sell',
      amount: tradeResult.volume,
      price: tradeResult.openPrice,
      currentPrice: tradeResult.openPrice,
      status: tradeResult.status === 'FILLED' ? 'Completed' : 'Pending',
      date: new Date(),
      broker: 'MT5',
      brokerType: apiKey.broker,
      stopLoss: tradeResult.stopLoss,
      takeProfit: tradeResult.takeProfit,
      brokerResponse: JSON.stringify(tradeResult.brokerResponse)
    });

    emitTradeUpdate(userId, trade, 'create');

    res.status(201).json({
      success: true,
      message: 'Manual trade executed successfully',
      data: {
        tradeId: trade.id,
        orderId: trade.orderId,
        symbol: trade.symbol,
        type: trade.type,
        volume: trade.amount,
        openPrice: trade.price,
        stopLoss: tradeResult.stopLoss,
        takeProfit: tradeResult.takeProfit,
        status: trade.status,
        executionTime: tradeResult.executionTime
      }
    });

  } catch (error) {
    console.error('Execute manual trade error:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Failed to execute manual trade',
      details: error.message 
    });
  }
};

/**
 * Get Current Price for Symbol
 * GET /api/algo-trades/price/:symbol
 */
export const getSymbolPrice = async (req, res) => {
  try {
    const { symbol } = req.params;
    const { segment = 'Forex' } = req.query;
    const userId = req.user.id;

    // Get user's API key
    const apiKey = await ApiKey.findOne({
      where: { userId, segment, broker: 'MT5' }
    });

    if (!apiKey) {
      return res.status(404).json({ 
        success: false, 
        error: 'No MT5 API key found' 
      });
    }

    // Initialize broker
    const isConnected = await mt5Broker.healthCheck();
    if (!isConnected) {
      await mt5Broker.initialize({
        apiKey: apiKey.apiKey,
        accountId: apiKey.appName
      });
    }

    // Get price
    const price = await mt5Broker.getPrice(symbol.toUpperCase());

    res.json({
      success: true,
      data: price
    });

  } catch (error) {
    console.error('Get price error:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Failed to fetch price',
      details: error.message 
    });
  }
};

/**
 * Close Trade by Order ID
 * POST /api/algo-trades/close/:orderId
 */
export const closeAlgoTrade = async (req, res) => {
  try {
    const userId = req.user.id;
    const { orderId } = req.params;

    // Find trade in database
    const trade = await Trade.findOne({
      where: { orderId, userId }
    });

    if (!trade) {
      return res.status(404).json({ 
        success: false, 
        error: 'Trade not found' 
      });
    }

    // Get API key
    const apiKey = await ApiKey.findOne({
      where: { 
        userId, 
        segment: trade.market,
        broker: 'MT5'
      }
    });

    if (!apiKey) {
      return res.status(404).json({ 
        success: false, 
        error: 'No MT5 API key found' 
      });
    }

    // Initialize broker
    const isConnected = await mt5Broker.healthCheck();
    if (!isConnected) {
      await mt5Broker.initialize({
        apiKey: apiKey.apiKey,
        accountId: apiKey.appName
      });
    }

    // Close trade
    const closeResult = await mt5Broker.closeTrade(orderId);

    // Update database
    await trade.update({
      status: closeResult?.success ? 'Completed' : 'Failed',
      currentPrice: closeResult.closePrice,
      pnl: closeResult.profit,
      pnlPercentage: closeResult.profitPercent,
      brokerResponse: closeResult?.success ? 'Closed successfully' : (closeResult?.error || 'Close failed'),
      brokerResponseJson: {
        source: 'TradingView Close Webhook',
        raw: closeResult,
        timestamp: new Date().toISOString()
      }
    });

    emitTradeUpdate(userId, trade, 'update');

    res.json({
      success: true,
      message: 'Trade closed successfully',
      data: {
        orderId: trade.orderId,
        closePrice: closeResult.closePrice,
        profit: closeResult.profit,
        profitPercent: closeResult.profitPercent
      }
    });

  } catch (error) {
    console.error('Close trade error:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Failed to close trade',
      details: error.message 
    });
  }
};

/**
 * Get Open Positions
 * GET /api/algo-trades/positions
 */
export const getOpenPositions = async (req, res) => {
  try {
    const userId = req.user.id;
    const { segment = 'Forex' } = req.query;

    // Get API key
    const apiKey = await ApiKey.findOne({
      where: { userId, segment, broker: 'MT5' }
    });

    if (!apiKey) {
      return res.status(404).json({ 
        success: false, 
        error: 'No MT5 API key found' 
      });
    }

    // Initialize broker
    const isConnected = await mt5Broker.healthCheck();
    if (!isConnected) {
      await mt5Broker.initialize({
        apiKey: apiKey.apiKey,
        accountId: apiKey.appName
      });
    }

    // Get open positions
    const positions = await mt5Broker.getOpenOrders();

    res.json({
      success: true,
      data: positions,
      count: positions.length
    });

  } catch (error) {
    console.error('Get positions error:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Failed to fetch open positions',
      details: error.message 
    });
  }
};

/**
 * Get Account Information
 * GET /api/algo-trades/account
 */
export const getAccountInfo = async (req, res) => {
  try {
    const userId = req.user.id;
    const { segment = 'Forex' } = req.query;

    // Get API key
    const apiKey = await ApiKey.findOne({
      where: { userId, segment, broker: 'MT5' }
    });

    if (!apiKey) {
      return res.status(404).json({ 
        success: false, 
        error: 'No MT5 API key found' 
      });
    }

    // Initialize broker
    const isConnected = await mt5Broker.healthCheck();
    if (!isConnected) {
      await mt5Broker.initialize({
        apiKey: apiKey.apiKey,
        accountId: apiKey.appName
      });
    }

    // Get account info
    const accountInfo = await mt5Broker.getAccountInfo();

    res.json({
      success: true,
      data: accountInfo
    });

  } catch (error) {
    console.error('Get account info error:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Failed to fetch account information',
      details: error.message 
    });
  }
};

/**
 * Get Multiple Symbol Prices (Batch Request)
 * POST /api/algo-trades/prices
 * @body { symbols: string[], segment?: string }
 */
export const getMultipleSymbolPrices = async (req, res) => {
  try {
    const userId = req.user.id;
    const { symbols, segment = 'Forex' } = req.body;

    if (!symbols || !Array.isArray(symbols) || symbols.length === 0) {
      return res.status(400).json({ 
        success: false, 
        error: 'Symbols array is required',
        example: { symbols: ['EURUSD', 'GBPUSD'], segment: 'Forex' }
      });
    }

    // Get API key
    const apiKey = await ApiKey.findOne({
      where: { userId, segment, broker: 'MT5' }
    });

    if (!apiKey) {
      return res.status(404).json({ 
        success: false, 
        error: 'No MT5 API key found for segment: ' + segment 
      });
    }

    // Initialize broker if needed
    const isConnected = await mt5Broker.healthCheck();
    if (!isConnected) {
      await mt5Broker.initialize({
        apiKey: apiKey.accessToken || apiKey.apiKey,
        accountId: apiKey.appName
      });
    }

    // Fetch prices for all symbols
    const prices = {};
    const errors = {};

    console.log(`üìä Fetching prices for ${symbols.length} symbols:`, symbols);

    for (const symbol of symbols) {
      try {
        const price = await mt5Broker.getPrice(symbol);
        prices[symbol] = {
          bid: price.bid,
          ask: price.ask,
          last: price.last || price.bid,
          spread: price.ask - price.bid,
          time: new Date().toISOString()
        };
        console.log(`‚úÖ Price fetched for ${symbol}:`, prices[symbol]);
      } catch (error) {
        console.error(`‚ùå Failed to fetch price for ${symbol}:`, error.message);
        errors[symbol] = error.message;
      }
    }

    console.log('üì§ Sending price response:', { success: true, symbolCount: Object.keys(prices).length });

    res.json({
      success: true,
      data: prices,
      errors: Object.keys(errors).length > 0 ? errors : undefined,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('Get multiple prices error:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Failed to fetch symbol prices',
      details: error.message 
    });
  }
};
/**
 * Execute Trade from TradingView Webhook (Multi-Subscriber)
 * POST /api/algo-trades/webhook
 * 
 * NEW: Uses strategy-level secret. All active subscribers receive trades.
 * 
 * TradingView Webhook Format:
 * {
 *   "secret": "ST123456",    // Strategy's webhook secret (not user secret)
 *   "signal": "BUY" | "SELL" | 0,
 *   "symbol": "EURUSD" (optional)
 * }
 */
export const executeTradingViewWebhook = async (req, res) => {
  try {
    const { secret, signal, symbol: customSymbol } = req.body;
    const signalReceivedAt = new Date();

    // Validate secret
    if (!secret) {
      console.warn('‚ùå Missing secret key');
      return res.status(401).json({ 
        success: false, 
        error: 'Authentication required',
        message: 'Strategy webhook secret is required',
        example: { secret: "ST123456", signal: "BUY" }
      });
    }

    // Find strategy by webhook secret
    const strategy = await Strategy.findOne({
      where: { webhookSecret: secret },
      include: [
        {
          model: User,
          as: 'user',
          attributes: ['id', 'name', 'email']
        }
      ]
    });

    if (!strategy) {
      console.warn(`‚ùå Invalid webhook secret: ${secret}`);
      return res.status(401).json({ 
        success: false, 
        error: 'Authentication failed',
        message: 'Invalid strategy webhook secret',
        receivedSecret: secret
      });
    }

    // Log webhook receipt
    console.log(`üì° Webhook received from ${req.ip}:`, { 
      strategyId: strategy.id, 
      strategyName: strategy.name,
      strategyOwner: strategy.user?.email,
      signal, 
      symbol: customSymbol 
    });

    // Parse signal: BUY/SELL/buy/sell or numeric (positive=BUY, negative=SELL, 0=CLOSE)
    let parsedSignal;
    let isCloseSignal = false;
    
    if (signal === 0 || signal === '0') {
      isCloseSignal = true;
      parsedSignal = 'CLOSE';
    } else if (typeof signal === 'number') {
      parsedSignal = signal > 0 ? 'BUY' : 'SELL';
    } else if (typeof signal === 'string') {
      const upperSignal = signal.toUpperCase();
      if (['BUY', 'SELL'].includes(upperSignal)) {
        parsedSignal = upperSignal;
      } else {
        // Try to parse as number
        const numSignal = parseFloat(signal);
        if (isNaN(numSignal)) {
          console.warn(`‚ùå Invalid signal: ${signal}`);
          return res.status(400).json({ 
            success: false, 
            error: 'Invalid signal',
            message: 'signal must be: "BUY", "SELL", positive number (buy), negative number (sell), or 0 (close)',
            received: signal,
            examples: ['BUY', 'SELL', '1', '-1', '0']
          });
        }
        if (numSignal === 0) {
          isCloseSignal = true;
          parsedSignal = 'CLOSE';
        } else {
          parsedSignal = numSignal > 0 ? 'BUY' : 'SELL';
        }
      }
    } else {
      console.warn(`‚ùå Invalid signal type: ${typeof signal}`);
      return res.status(400).json({ 
        success: false, 
        error: 'Invalid signal',
        message: 'signal must be string or number',
        received: signal
      });
    }

    console.log(`‚úÖ Signal parsed: ${parsedSignal}`);

    // Check if strategy is active
    if (!strategy.isActive) {
      console.warn(`‚ùå Strategy ${strategy.name} is inactive`);
      return res.status(400).json({ 
        success: false, 
        error: 'Strategy inactive',
        message: `Strategy "${strategy.name}" is currently disabled`,
        strategyId: strategy.id,
        strategyName: strategy.name,
        isActive: false
      });
    }

    // Get trading symbol
    const symbol = customSymbol || strategy.symbol;
    if (!symbol) {
      console.warn(`‚ùå No symbol for strategy ${strategy.name}`);
      return res.status(400).json({ 
        success: false, 
        error: 'Missing symbol',
        message: 'Trading symbol is required. Add it to strategy or send in webhook payload.',
        strategyId: strategy.id,
        strategyName: strategy.name
      });
    }

    // Parse market risk configuration
    const marketRisk = strategy.marketRisk || {};
    const {
      stopLossType = 'points',
      stopLossValue = 50,
      takeProfitType = 'points',
      takeProfitValue = 100,
      riskPercent = 1,
      usePositionSizing = false
    } = marketRisk;

    // Get user's API key
    const apiKey = await ApiKey.findOne({
      where: { 
        userId,
        segment: strategy.segment,
        broker: 'MT5'
      }
    });

    if (!apiKey) {
      console.warn(`‚ùå No API key for ${strategy.segment}`);
      return res.status(404).json({ 
        success: false, 
        error: 'Broker credentials missing',
        message: `No MT5 API key configured for ${strategy.segment} segment`,
        segment: strategy.segment,
        solution: 'Add MT5 credentials in API Keys settings'
      });
    }

    // Validate MT5 credentials
    if (!apiKey.accessToken || !apiKey.appName) {
      console.warn(`‚ùå Invalid MT5 credentials for user ${userId}`);
      return res.status(400).json({ 
        success: false, 
        error: 'Invalid MT5 credentials',
        message: 'Access Token and Account ID are required',
        details: {
          hasAccessToken: !!apiKey.accessToken,
          hasAccountId: !!apiKey.appName
        },
        solution: 'Update your MT5 API key with valid Access Token and Account ID'
      });
    }

    // Get volume
    const volume = strategy.lots || 0.01;

    // Initialize MT5 broker
    try {
      const isConnected = await mt5Broker.healthCheck();
      if (!isConnected) {
        await mt5Broker.initialize({
          apiKey: apiKey.accessToken, // MetaAPI JWT token
          accountId: apiKey.appName   // MT5 account ID
        });
      }
    } catch (initError) {
      console.error('MT5 initialization error:', initError);
      return res.status(500).json({ 
        success: false, 
        error: 'Failed to connect to MT5 broker',
        details: initError.message
      });
    }

    // Handle CLOSE signal - close only the last executed trade for this strategy
    if (isCloseSignal) {
      console.log(`üîÑ Close signal received for strategy ${strategyId}`);
      
      try {
        // Get the last executed trade for this strategy
        const lastTrade = await Trade.findOne({
          where: {
            userId,
            strategyId,
            status: { [Op.or]: ['Pending', 'Open', 'Completed'] }
          },
          order: [['id', 'DESC']] // Get the most recent trade
        });
        
        if (!lastTrade) {
          console.log(`‚ÑπÔ∏è No open trades found for strategy ${strategyId}`);
          return res.status(200).json({
            success: true,
            message: 'No open position to close',
            strategyId: strategyId
          });
        }
        
        console.log(`üéØ Closing last trade: ${lastTrade.orderId}`);
        
        // Close the position
        try {
          const closeResult = await mt5Broker.closeTrade(lastTrade.orderId);
          
          if (closeResult.success) {
            // Update trade status
            await lastTrade.update({
              status: 'Completed',
              signalReceivedAt,
              signalPayload: {
                source: 'TradingView',
                requestIp: req.ip,
                strategyId,
                signal: 'CLOSE',
                symbol: (customSymbol || strategy.symbol || lastTrade.symbol || '').toUpperCase(),
                raw: req.body
              },
              signalSendStatus: 'Sent',
              signalSendError: null,
              brokerStatus: 'CLOSED',
              brokerError: null,
              brokerResponse: JSON.stringify({ status: 'CLOSED' }),
              brokerResponseJson: {
                raw: closeResult,
                timestamp: new Date().toISOString()
              }
            });
            
            console.log(`‚úÖ Closed position ${lastTrade.orderId}`);
            
            // Emit real-time update
            emitTradeUpdate(userId, lastTrade, 'update');
            
            return res.status(200).json({
              success: true,
              message: '‚úÖ Last position closed successfully',
              webhook: {
                signal: 'CLOSE',
                receivedAt: new Date().toISOString(),
                source: 'TradingView'
              },
              strategy: {
                id: strategy.id,
                name: strategy.name
              },
              closedTrade: {
                tradeId: lastTrade.id,
                orderId: lastTrade.orderId,
                symbol: lastTrade.symbol,
                type: lastTrade.type,
                volume: lastTrade.amount,
                openPrice: lastTrade.price
              }
            });
          } else {
            throw new Error(closeResult.error || 'Failed to close position');
          }
        } catch (closeError) {
          console.error(`Failed to close position ${lastTrade.orderId}:`, closeError);

          // Persist close failure for audit (best-effort)
          try {
            await lastTrade.update({
              signalReceivedAt,
              signalPayload: {
                source: 'TradingView',
                requestIp: req.ip,
                strategyId,
                signal: 'CLOSE',
                symbol: (customSymbol || strategy.symbol || lastTrade.symbol || '').toUpperCase(),
                raw: req.body
              },
              signalSendStatus: 'Failed',
              signalSendError: closeError?.message,
              brokerStatus: 'FAILED',
              brokerError: closeError?.message,
              brokerResponse: closeError?.message,
              brokerResponseJson: {
                error: closeError?.message,
                stack: closeError?.stack,
                timestamp: new Date().toISOString()
              }
            });
          } catch (e) {
            // ignore
          }

          return res.status(500).json({
            success: false,
            error: 'Failed to close position',
            details: closeError.message,
            orderId: lastTrade.orderId
          });
        }
        
      } catch (closeError) {
        console.error('Error closing position:', closeError);
        return res.status(500).json({
          success: false,
          error: 'Failed to close position',
          details: closeError.message
        });
      }
    }

    // Get account info
    let accountInfo;
    try {
      accountInfo = await mt5Broker.getAccountInfo();
    } catch (accountError) {
      console.error('Get account info error:', accountError);
      return res.status(500).json({ 
        success: false, 
        error: 'Failed to retrieve account information',
        details: accountError.message
      });
    }

    // Calculate position size if enabled
    let calculatedVolume = volume;
    if (usePositionSizing && accountInfo) {
      try {
        const currentPrice = await mt5Broker.getPrice(symbol);
        const slPrice = parsedSignal === 'BUY' 
          ? currentPrice.bid - (stopLossValue * 0.0001)
          : currentPrice.ask + (stopLossValue * 0.0001);
        
        const { CalculationService } = await import('../../algoengine/brokers/mt5/services/CalculationService.js');
        calculatedVolume = CalculationService.calculatePositionSize(
          accountInfo.balance,
          riskPercent,
          currentPrice.bid,
          slPrice
        );
        
        calculatedVolume = Math.max(0.01, Math.round(calculatedVolume * 100) / 100);
      } catch (sizeError) {
        console.error('Position sizing error:', sizeError);
      }
    }

    // Prepare trade parameters
    const tradeParams = {
      symbol: symbol.toUpperCase(),
      type: parsedSignal,
      volume: calculatedVolume,
      stopLoss: {
        type: stopLossType,
        value: stopLossValue
      },
      takeProfit: {
        type: takeProfitType,
        value: takeProfitValue
      },
      comment: `TradingView: ${strategy.name} (ID: ${strategyId})`
    };

    // Execute trade
    let tradeResult;
    try {
      console.log(`üöÄ Executing ${parsedSignal} trade via webhook:`, tradeParams);
      tradeResult = await mt5Broker.placeTrade(tradeParams);
      
      // Check if trade was successful
      if (!tradeResult || !tradeResult.success) {
        throw new Error(tradeResult?.error || 'Trade execution returned unsuccessful result');
      }
      
      // Validate required fields
      if (!tradeResult.orderId && !tradeResult.brokerOrderId) {
        throw new Error('Trade executed but orderId is missing');
      }
      if (!tradeResult.volume && !tradeResult.amount) {
        throw new Error('Trade executed but volume is missing');
      }
      if (!tradeResult.openPrice) {
        throw new Error('Trade executed but openPrice is missing');
      }
      
    } catch (tradeError) {
      console.error('Trade execution error:', tradeError);
      
      // Save failed trade
      const failedTrade = await Trade.create({
        userId,
        orderId: `WEBHOOK_FAILED_${Date.now()}`,
        market: strategy.segment,
        symbol: symbol.toUpperCase(),
        type: parsedSignal === 'BUY' ? 'Buy' : 'Sell',
        amount: calculatedVolume,
        price: 0,
        status: 'Failed',
        date: new Date(),
        broker: 'MT5',
        brokerType: apiKey.broker,
        strategyId: strategyId,
        // Order-log fields
        signalReceivedAt,
        signalPayload: {
          source: 'TradingView',
          requestIp: req.ip,
          strategyId,
          signal: parsedSignal,
          symbol: symbol.toUpperCase(),
          raw: req.body
        },
        signalSendStatus: 'Failed',
        signalSendError: tradeError?.message,
        filledQuantity: null,
        avgFillPrice: null,
        brokerStatus: 'REJECTED',
        brokerError: tradeError?.message,
        brokerResponse: tradeError?.message,
        brokerResponseJson: {
          error: tradeError?.message,
          source: 'TradingView Webhook',
          name: tradeError?.name,
          stack: tradeError?.stack,
          timestamp: new Date().toISOString()
        }
      });

      return res.status(500).json({ 
        success: false, 
        error: 'Trade execution failed',
        details: tradeError.message,
        tradeId: failedTrade.id
      });
    }

    // Save successful trade
    const trade = await Trade.create({
      userId,
      orderId: tradeResult.brokerOrderId || tradeResult.orderId,
      market: strategy.segment,
      symbol: symbol.toUpperCase(),
      type: parsedSignal === 'BUY' ? 'Buy' : 'Sell',
      amount: tradeResult.volume,
      price: tradeResult.openPrice,
      currentPrice: tradeResult.openPrice,
      status: tradeResult.status === 'FILLED' ? 'Completed' : 'Pending',
      date: new Date(),
      broker: 'MT5',
      brokerType: apiKey.broker,
      strategyId: strategyId,
      // Order-log fields
      signalReceivedAt,
      signalPayload: {
        source: 'TradingView',
        requestIp: req.ip,
        strategyId,
        signal: parsedSignal,
        symbol: symbol.toUpperCase(),
        raw: req.body
      },
      signalSendStatus: 'Sent',
      signalSendError: null,
      filledQuantity: tradeResult?.volume ?? tradeResult?.amount ?? calculatedVolume,
      avgFillPrice: tradeResult?.openPrice ?? null,
      brokerStatus: tradeResult?.status || 'UNKNOWN',
      brokerError: null,
      brokerResponse: JSON.stringify({ status: tradeResult?.status || 'UNKNOWN' }),
      brokerResponseJson: {
        ...tradeResult?.brokerResponse,
        executionTime: tradeResult?.executionTime,
        source: 'TradingView Webhook',
        raw: tradeResult,
        timestamp: new Date().toISOString()
      }
    });

    console.log(`‚úÖ Webhook trade executed: ${trade.orderId} - ${parsedSignal} ${calculatedVolume} ${symbol.toUpperCase()} @ ${tradeResult.openPrice}`);

    // Emit real-time update
    emitTradeUpdate(userId, trade, 'create');

    // Send success response
    res.status(201).json({
      success: true,
      message: '‚úÖ Signal received and trade executed',
      webhook: {
        signal: parsedSignal,
        receivedAt: new Date().toISOString(),
        source: 'TradingView'
      },
      trade: {
        tradeId: trade.id,
        orderId: trade.orderId,
        symbol: trade.symbol,
        type: trade.type,
        volume: trade.amount,
        openPrice: trade.price,
        status: trade.status,
        executionTime: tradeResult.executionTime
      },
      strategy: {
        id: strategy.id,
        name: strategy.name,
        segment: strategy.segment
      },
      broker: {
        name: 'MT5',
        account: accountInfo.broker
      }
    });

  } catch (error) {
    console.error('‚ùå Webhook processing error:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Webhook processing failed',
      message: 'An unexpected error occurred while processing the webhook',
      details: error.message,
      timestamp: new Date().toISOString(),
      solution: 'Check webhook payload format and try again'
    });
  }
};
